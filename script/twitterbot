#!/usr/bin/env ruby

# a simple twitter <-> urbantakeover gateway.
# no parsing happens here, we just pass all messages to the urban takeover message handler
# and return the result if there's any

require "xmpp4r"
require "net/http"
require "cgi"
require "iconv"

def dispatch_to_rails user, msg
  req = Net::HTTP.get_response(URI.parse("http://localhost:3000/gateway/twitter?user=#{user}&message=#{msg}"))
  return req.body[0...150]
end

client = Jabber::Client.new(Jabber::JID.new('cbo.jabber@gmail.com/google'))
client.connect
client.auth('claimme12')

print "ready!l"
client.send(Jabber::Presence.new.set_show(:chat).set_status('This is so 1985!'))

client.add_message_callback { |msg|
  if msg.body
    puts "Incoming msg from #{msg.from}: #{msg.body}"
    answer = Jabber::Message.new(msg.from)
    answer.type = :chat
    if(msg.body.match('Direct from (.*):\n'))
      request = msg.body.match(':\n(.*)')[1]
      benutzer = msg.body.match('Direct from (.*):\n')[1]
      ut_status = dispatch_to_rails(benutzer, request)
      answer.body = "d #{benutzer} #{ut_status}"
      puts "Outgoing msg to #{msg.from}: #{answer.body}"
      client.send(answer)
    end
  end
}

Thread.stop

#require "twitter"
#
#twitter = Twitter::Client.new( :login => 'sdsantos' , :password => 'xxxxxxx' )
#messages = twitter.messages(:received)
#
#messages.each do |message|
#  print message
#end

#Jabber::debug = true
# 
#print "boot jabber!"
#client = Jabber::Client.new(Jabber::JID.new('cbo.jabber@gmail.com/google'))
#
#print "connect!"
#client.connect
#
#print "auth!"
#client.auth('claimme12')
#
#print "set status!"
#client.send(Jabber::Presence.new.set_show(:chat).set_status('This is so 1985!'))
#
#print "ready!"
#
#client.add_message_callback { |msg|
#  if msg.body
#    puts "Incoming msg from #{msg.from}: #{msg.body}"
#    answer = Jabber::Message.new(msg.from)
#    answer.type = :chat
#    msg.body.match(':\n(.*)').should   {
#      request = msg.body.match(':\n(.*)')[1]
#      user = msg.body.match('Direct from (.*):\n')[1]
#      answer.body = "d #{user} haha"
#      puts "Outgoing msg to #{msg.from}: #{answer.body}"
#      client.send(answer)
#    }
#  end
#}
#
#Thread.stop




#require 'xmpp4r/client'
#include Jabber
#
# Login
#jid = JID::new('test@yeush.com/Testing')
#password = 'test'
#cl = Client::new(jid)
#cl.connect
#cl.auth(password)
#
## Create a message
#to = "test_with_me@yeush.com"
#subject = "XMPP4R Rich-Text Test"
#body = "Wow, I can do HTML now. But if you see this, your client doesn't support it"
#m = Message::new(to, body).set_type(:normal).set_id('1').set_subject(subject)
#
## Create the html part
#h = REXML::Element::new("html")
#h.add_namespace('http://jabber.org/protocol/xhtml-im')
#
## The body part with the correct namespace
#b = REXML::Element::new("body")
#b.add_namespace('http://www.w3.org/1999/xhtml')
#
## The html itself
#t = REXML::Text.new( "This is so <strong><span style='background: #003EFF; '><span style='font-size: large; '>COOL!!!</span></span></strong>. I can really do <strong>HTML</strong> now.", false, nil, true, nil, %r/.^/ )
#
## Add the html text to the body, and the body to the html element
#b.add(t)
#h.add(b)
#
## Add the html element to the message
#m.add_element(h)
#
## Send it
#cl.send m